// Code generated by counterfeiter. DO NOT EDIT.
package fake

import (
	"context"
	"sync"

	"github.com/crhntr/muxt-template-module-todo/internal/database"
)

type Querier struct {
	DeleteListStub        func(context.Context, database.DBTX, int64) error
	deleteListMutex       sync.RWMutex
	deleteListArgsForCall []struct {
		arg1 context.Context
		arg2 database.DBTX
		arg3 int64
	}
	deleteListReturns struct {
		result1 error
	}
	deleteListReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteTaskStub        func(context.Context, database.DBTX, int64) error
	deleteTaskMutex       sync.RWMutex
	deleteTaskArgsForCall []struct {
		arg1 context.Context
		arg2 database.DBTX
		arg3 int64
	}
	deleteTaskReturns struct {
		result1 error
	}
	deleteTaskReturnsOnCall map[int]struct {
		result1 error
	}
	InsertListStub        func(context.Context, database.DBTX, database.InsertListParams) (database.List, error)
	insertListMutex       sync.RWMutex
	insertListArgsForCall []struct {
		arg1 context.Context
		arg2 database.DBTX
		arg3 database.InsertListParams
	}
	insertListReturns struct {
		result1 database.List
		result2 error
	}
	insertListReturnsOnCall map[int]struct {
		result1 database.List
		result2 error
	}
	InsertTaskStub        func(context.Context, database.DBTX, database.InsertTaskParams) (database.Task, error)
	insertTaskMutex       sync.RWMutex
	insertTaskArgsForCall []struct {
		arg1 context.Context
		arg2 database.DBTX
		arg3 database.InsertTaskParams
	}
	insertTaskReturns struct {
		result1 database.Task
		result2 error
	}
	insertTaskReturnsOnCall map[int]struct {
		result1 database.Task
		result2 error
	}
	SelectListStub        func(context.Context, database.DBTX, int64) (database.List, error)
	selectListMutex       sync.RWMutex
	selectListArgsForCall []struct {
		arg1 context.Context
		arg2 database.DBTX
		arg3 int64
	}
	selectListReturns struct {
		result1 database.List
		result2 error
	}
	selectListReturnsOnCall map[int]struct {
		result1 database.List
		result2 error
	}
	SelectListsStub        func(context.Context, database.DBTX) ([]database.List, error)
	selectListsMutex       sync.RWMutex
	selectListsArgsForCall []struct {
		arg1 context.Context
		arg2 database.DBTX
	}
	selectListsReturns struct {
		result1 []database.List
		result2 error
	}
	selectListsReturnsOnCall map[int]struct {
		result1 []database.List
		result2 error
	}
	SelectTasksForListStub        func(context.Context, database.DBTX, int64) ([]database.Task, error)
	selectTasksForListMutex       sync.RWMutex
	selectTasksForListArgsForCall []struct {
		arg1 context.Context
		arg2 database.DBTX
		arg3 int64
	}
	selectTasksForListReturns struct {
		result1 []database.Task
		result2 error
	}
	selectTasksForListReturnsOnCall map[int]struct {
		result1 []database.Task
		result2 error
	}
	UpdateListStub        func(context.Context, database.DBTX, database.UpdateListParams) (database.List, error)
	updateListMutex       sync.RWMutex
	updateListArgsForCall []struct {
		arg1 context.Context
		arg2 database.DBTX
		arg3 database.UpdateListParams
	}
	updateListReturns struct {
		result1 database.List
		result2 error
	}
	updateListReturnsOnCall map[int]struct {
		result1 database.List
		result2 error
	}
	UpdateTaskSetCompletedAtNowStub        func(context.Context, database.DBTX, int64) (database.Task, error)
	updateTaskSetCompletedAtNowMutex       sync.RWMutex
	updateTaskSetCompletedAtNowArgsForCall []struct {
		arg1 context.Context
		arg2 database.DBTX
		arg3 int64
	}
	updateTaskSetCompletedAtNowReturns struct {
		result1 database.Task
		result2 error
	}
	updateTaskSetCompletedAtNowReturnsOnCall map[int]struct {
		result1 database.Task
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *Querier) DeleteList(arg1 context.Context, arg2 database.DBTX, arg3 int64) error {
	fake.deleteListMutex.Lock()
	ret, specificReturn := fake.deleteListReturnsOnCall[len(fake.deleteListArgsForCall)]
	fake.deleteListArgsForCall = append(fake.deleteListArgsForCall, struct {
		arg1 context.Context
		arg2 database.DBTX
		arg3 int64
	}{arg1, arg2, arg3})
	stub := fake.DeleteListStub
	fakeReturns := fake.deleteListReturns
	fake.recordInvocation("DeleteList", []interface{}{arg1, arg2, arg3})
	fake.deleteListMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Querier) DeleteListCallCount() int {
	fake.deleteListMutex.RLock()
	defer fake.deleteListMutex.RUnlock()
	return len(fake.deleteListArgsForCall)
}

func (fake *Querier) DeleteListCalls(stub func(context.Context, database.DBTX, int64) error) {
	fake.deleteListMutex.Lock()
	defer fake.deleteListMutex.Unlock()
	fake.DeleteListStub = stub
}

func (fake *Querier) DeleteListArgsForCall(i int) (context.Context, database.DBTX, int64) {
	fake.deleteListMutex.RLock()
	defer fake.deleteListMutex.RUnlock()
	argsForCall := fake.deleteListArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Querier) DeleteListReturns(result1 error) {
	fake.deleteListMutex.Lock()
	defer fake.deleteListMutex.Unlock()
	fake.DeleteListStub = nil
	fake.deleteListReturns = struct {
		result1 error
	}{result1}
}

func (fake *Querier) DeleteListReturnsOnCall(i int, result1 error) {
	fake.deleteListMutex.Lock()
	defer fake.deleteListMutex.Unlock()
	fake.DeleteListStub = nil
	if fake.deleteListReturnsOnCall == nil {
		fake.deleteListReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteListReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Querier) DeleteTask(arg1 context.Context, arg2 database.DBTX, arg3 int64) error {
	fake.deleteTaskMutex.Lock()
	ret, specificReturn := fake.deleteTaskReturnsOnCall[len(fake.deleteTaskArgsForCall)]
	fake.deleteTaskArgsForCall = append(fake.deleteTaskArgsForCall, struct {
		arg1 context.Context
		arg2 database.DBTX
		arg3 int64
	}{arg1, arg2, arg3})
	stub := fake.DeleteTaskStub
	fakeReturns := fake.deleteTaskReturns
	fake.recordInvocation("DeleteTask", []interface{}{arg1, arg2, arg3})
	fake.deleteTaskMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *Querier) DeleteTaskCallCount() int {
	fake.deleteTaskMutex.RLock()
	defer fake.deleteTaskMutex.RUnlock()
	return len(fake.deleteTaskArgsForCall)
}

func (fake *Querier) DeleteTaskCalls(stub func(context.Context, database.DBTX, int64) error) {
	fake.deleteTaskMutex.Lock()
	defer fake.deleteTaskMutex.Unlock()
	fake.DeleteTaskStub = stub
}

func (fake *Querier) DeleteTaskArgsForCall(i int) (context.Context, database.DBTX, int64) {
	fake.deleteTaskMutex.RLock()
	defer fake.deleteTaskMutex.RUnlock()
	argsForCall := fake.deleteTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Querier) DeleteTaskReturns(result1 error) {
	fake.deleteTaskMutex.Lock()
	defer fake.deleteTaskMutex.Unlock()
	fake.DeleteTaskStub = nil
	fake.deleteTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *Querier) DeleteTaskReturnsOnCall(i int, result1 error) {
	fake.deleteTaskMutex.Lock()
	defer fake.deleteTaskMutex.Unlock()
	fake.DeleteTaskStub = nil
	if fake.deleteTaskReturnsOnCall == nil {
		fake.deleteTaskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteTaskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *Querier) InsertList(arg1 context.Context, arg2 database.DBTX, arg3 database.InsertListParams) (database.List, error) {
	fake.insertListMutex.Lock()
	ret, specificReturn := fake.insertListReturnsOnCall[len(fake.insertListArgsForCall)]
	fake.insertListArgsForCall = append(fake.insertListArgsForCall, struct {
		arg1 context.Context
		arg2 database.DBTX
		arg3 database.InsertListParams
	}{arg1, arg2, arg3})
	stub := fake.InsertListStub
	fakeReturns := fake.insertListReturns
	fake.recordInvocation("InsertList", []interface{}{arg1, arg2, arg3})
	fake.insertListMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Querier) InsertListCallCount() int {
	fake.insertListMutex.RLock()
	defer fake.insertListMutex.RUnlock()
	return len(fake.insertListArgsForCall)
}

func (fake *Querier) InsertListCalls(stub func(context.Context, database.DBTX, database.InsertListParams) (database.List, error)) {
	fake.insertListMutex.Lock()
	defer fake.insertListMutex.Unlock()
	fake.InsertListStub = stub
}

func (fake *Querier) InsertListArgsForCall(i int) (context.Context, database.DBTX, database.InsertListParams) {
	fake.insertListMutex.RLock()
	defer fake.insertListMutex.RUnlock()
	argsForCall := fake.insertListArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Querier) InsertListReturns(result1 database.List, result2 error) {
	fake.insertListMutex.Lock()
	defer fake.insertListMutex.Unlock()
	fake.InsertListStub = nil
	fake.insertListReturns = struct {
		result1 database.List
		result2 error
	}{result1, result2}
}

func (fake *Querier) InsertListReturnsOnCall(i int, result1 database.List, result2 error) {
	fake.insertListMutex.Lock()
	defer fake.insertListMutex.Unlock()
	fake.InsertListStub = nil
	if fake.insertListReturnsOnCall == nil {
		fake.insertListReturnsOnCall = make(map[int]struct {
			result1 database.List
			result2 error
		})
	}
	fake.insertListReturnsOnCall[i] = struct {
		result1 database.List
		result2 error
	}{result1, result2}
}

func (fake *Querier) InsertTask(arg1 context.Context, arg2 database.DBTX, arg3 database.InsertTaskParams) (database.Task, error) {
	fake.insertTaskMutex.Lock()
	ret, specificReturn := fake.insertTaskReturnsOnCall[len(fake.insertTaskArgsForCall)]
	fake.insertTaskArgsForCall = append(fake.insertTaskArgsForCall, struct {
		arg1 context.Context
		arg2 database.DBTX
		arg3 database.InsertTaskParams
	}{arg1, arg2, arg3})
	stub := fake.InsertTaskStub
	fakeReturns := fake.insertTaskReturns
	fake.recordInvocation("InsertTask", []interface{}{arg1, arg2, arg3})
	fake.insertTaskMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Querier) InsertTaskCallCount() int {
	fake.insertTaskMutex.RLock()
	defer fake.insertTaskMutex.RUnlock()
	return len(fake.insertTaskArgsForCall)
}

func (fake *Querier) InsertTaskCalls(stub func(context.Context, database.DBTX, database.InsertTaskParams) (database.Task, error)) {
	fake.insertTaskMutex.Lock()
	defer fake.insertTaskMutex.Unlock()
	fake.InsertTaskStub = stub
}

func (fake *Querier) InsertTaskArgsForCall(i int) (context.Context, database.DBTX, database.InsertTaskParams) {
	fake.insertTaskMutex.RLock()
	defer fake.insertTaskMutex.RUnlock()
	argsForCall := fake.insertTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Querier) InsertTaskReturns(result1 database.Task, result2 error) {
	fake.insertTaskMutex.Lock()
	defer fake.insertTaskMutex.Unlock()
	fake.InsertTaskStub = nil
	fake.insertTaskReturns = struct {
		result1 database.Task
		result2 error
	}{result1, result2}
}

func (fake *Querier) InsertTaskReturnsOnCall(i int, result1 database.Task, result2 error) {
	fake.insertTaskMutex.Lock()
	defer fake.insertTaskMutex.Unlock()
	fake.InsertTaskStub = nil
	if fake.insertTaskReturnsOnCall == nil {
		fake.insertTaskReturnsOnCall = make(map[int]struct {
			result1 database.Task
			result2 error
		})
	}
	fake.insertTaskReturnsOnCall[i] = struct {
		result1 database.Task
		result2 error
	}{result1, result2}
}

func (fake *Querier) SelectList(arg1 context.Context, arg2 database.DBTX, arg3 int64) (database.List, error) {
	fake.selectListMutex.Lock()
	ret, specificReturn := fake.selectListReturnsOnCall[len(fake.selectListArgsForCall)]
	fake.selectListArgsForCall = append(fake.selectListArgsForCall, struct {
		arg1 context.Context
		arg2 database.DBTX
		arg3 int64
	}{arg1, arg2, arg3})
	stub := fake.SelectListStub
	fakeReturns := fake.selectListReturns
	fake.recordInvocation("SelectList", []interface{}{arg1, arg2, arg3})
	fake.selectListMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Querier) SelectListCallCount() int {
	fake.selectListMutex.RLock()
	defer fake.selectListMutex.RUnlock()
	return len(fake.selectListArgsForCall)
}

func (fake *Querier) SelectListCalls(stub func(context.Context, database.DBTX, int64) (database.List, error)) {
	fake.selectListMutex.Lock()
	defer fake.selectListMutex.Unlock()
	fake.SelectListStub = stub
}

func (fake *Querier) SelectListArgsForCall(i int) (context.Context, database.DBTX, int64) {
	fake.selectListMutex.RLock()
	defer fake.selectListMutex.RUnlock()
	argsForCall := fake.selectListArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Querier) SelectListReturns(result1 database.List, result2 error) {
	fake.selectListMutex.Lock()
	defer fake.selectListMutex.Unlock()
	fake.SelectListStub = nil
	fake.selectListReturns = struct {
		result1 database.List
		result2 error
	}{result1, result2}
}

func (fake *Querier) SelectListReturnsOnCall(i int, result1 database.List, result2 error) {
	fake.selectListMutex.Lock()
	defer fake.selectListMutex.Unlock()
	fake.SelectListStub = nil
	if fake.selectListReturnsOnCall == nil {
		fake.selectListReturnsOnCall = make(map[int]struct {
			result1 database.List
			result2 error
		})
	}
	fake.selectListReturnsOnCall[i] = struct {
		result1 database.List
		result2 error
	}{result1, result2}
}

func (fake *Querier) SelectLists(arg1 context.Context, arg2 database.DBTX) ([]database.List, error) {
	fake.selectListsMutex.Lock()
	ret, specificReturn := fake.selectListsReturnsOnCall[len(fake.selectListsArgsForCall)]
	fake.selectListsArgsForCall = append(fake.selectListsArgsForCall, struct {
		arg1 context.Context
		arg2 database.DBTX
	}{arg1, arg2})
	stub := fake.SelectListsStub
	fakeReturns := fake.selectListsReturns
	fake.recordInvocation("SelectLists", []interface{}{arg1, arg2})
	fake.selectListsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Querier) SelectListsCallCount() int {
	fake.selectListsMutex.RLock()
	defer fake.selectListsMutex.RUnlock()
	return len(fake.selectListsArgsForCall)
}

func (fake *Querier) SelectListsCalls(stub func(context.Context, database.DBTX) ([]database.List, error)) {
	fake.selectListsMutex.Lock()
	defer fake.selectListsMutex.Unlock()
	fake.SelectListsStub = stub
}

func (fake *Querier) SelectListsArgsForCall(i int) (context.Context, database.DBTX) {
	fake.selectListsMutex.RLock()
	defer fake.selectListsMutex.RUnlock()
	argsForCall := fake.selectListsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *Querier) SelectListsReturns(result1 []database.List, result2 error) {
	fake.selectListsMutex.Lock()
	defer fake.selectListsMutex.Unlock()
	fake.SelectListsStub = nil
	fake.selectListsReturns = struct {
		result1 []database.List
		result2 error
	}{result1, result2}
}

func (fake *Querier) SelectListsReturnsOnCall(i int, result1 []database.List, result2 error) {
	fake.selectListsMutex.Lock()
	defer fake.selectListsMutex.Unlock()
	fake.SelectListsStub = nil
	if fake.selectListsReturnsOnCall == nil {
		fake.selectListsReturnsOnCall = make(map[int]struct {
			result1 []database.List
			result2 error
		})
	}
	fake.selectListsReturnsOnCall[i] = struct {
		result1 []database.List
		result2 error
	}{result1, result2}
}

func (fake *Querier) SelectTasksForList(arg1 context.Context, arg2 database.DBTX, arg3 int64) ([]database.Task, error) {
	fake.selectTasksForListMutex.Lock()
	ret, specificReturn := fake.selectTasksForListReturnsOnCall[len(fake.selectTasksForListArgsForCall)]
	fake.selectTasksForListArgsForCall = append(fake.selectTasksForListArgsForCall, struct {
		arg1 context.Context
		arg2 database.DBTX
		arg3 int64
	}{arg1, arg2, arg3})
	stub := fake.SelectTasksForListStub
	fakeReturns := fake.selectTasksForListReturns
	fake.recordInvocation("SelectTasksForList", []interface{}{arg1, arg2, arg3})
	fake.selectTasksForListMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Querier) SelectTasksForListCallCount() int {
	fake.selectTasksForListMutex.RLock()
	defer fake.selectTasksForListMutex.RUnlock()
	return len(fake.selectTasksForListArgsForCall)
}

func (fake *Querier) SelectTasksForListCalls(stub func(context.Context, database.DBTX, int64) ([]database.Task, error)) {
	fake.selectTasksForListMutex.Lock()
	defer fake.selectTasksForListMutex.Unlock()
	fake.SelectTasksForListStub = stub
}

func (fake *Querier) SelectTasksForListArgsForCall(i int) (context.Context, database.DBTX, int64) {
	fake.selectTasksForListMutex.RLock()
	defer fake.selectTasksForListMutex.RUnlock()
	argsForCall := fake.selectTasksForListArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Querier) SelectTasksForListReturns(result1 []database.Task, result2 error) {
	fake.selectTasksForListMutex.Lock()
	defer fake.selectTasksForListMutex.Unlock()
	fake.SelectTasksForListStub = nil
	fake.selectTasksForListReturns = struct {
		result1 []database.Task
		result2 error
	}{result1, result2}
}

func (fake *Querier) SelectTasksForListReturnsOnCall(i int, result1 []database.Task, result2 error) {
	fake.selectTasksForListMutex.Lock()
	defer fake.selectTasksForListMutex.Unlock()
	fake.SelectTasksForListStub = nil
	if fake.selectTasksForListReturnsOnCall == nil {
		fake.selectTasksForListReturnsOnCall = make(map[int]struct {
			result1 []database.Task
			result2 error
		})
	}
	fake.selectTasksForListReturnsOnCall[i] = struct {
		result1 []database.Task
		result2 error
	}{result1, result2}
}

func (fake *Querier) UpdateList(arg1 context.Context, arg2 database.DBTX, arg3 database.UpdateListParams) (database.List, error) {
	fake.updateListMutex.Lock()
	ret, specificReturn := fake.updateListReturnsOnCall[len(fake.updateListArgsForCall)]
	fake.updateListArgsForCall = append(fake.updateListArgsForCall, struct {
		arg1 context.Context
		arg2 database.DBTX
		arg3 database.UpdateListParams
	}{arg1, arg2, arg3})
	stub := fake.UpdateListStub
	fakeReturns := fake.updateListReturns
	fake.recordInvocation("UpdateList", []interface{}{arg1, arg2, arg3})
	fake.updateListMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Querier) UpdateListCallCount() int {
	fake.updateListMutex.RLock()
	defer fake.updateListMutex.RUnlock()
	return len(fake.updateListArgsForCall)
}

func (fake *Querier) UpdateListCalls(stub func(context.Context, database.DBTX, database.UpdateListParams) (database.List, error)) {
	fake.updateListMutex.Lock()
	defer fake.updateListMutex.Unlock()
	fake.UpdateListStub = stub
}

func (fake *Querier) UpdateListArgsForCall(i int) (context.Context, database.DBTX, database.UpdateListParams) {
	fake.updateListMutex.RLock()
	defer fake.updateListMutex.RUnlock()
	argsForCall := fake.updateListArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Querier) UpdateListReturns(result1 database.List, result2 error) {
	fake.updateListMutex.Lock()
	defer fake.updateListMutex.Unlock()
	fake.UpdateListStub = nil
	fake.updateListReturns = struct {
		result1 database.List
		result2 error
	}{result1, result2}
}

func (fake *Querier) UpdateListReturnsOnCall(i int, result1 database.List, result2 error) {
	fake.updateListMutex.Lock()
	defer fake.updateListMutex.Unlock()
	fake.UpdateListStub = nil
	if fake.updateListReturnsOnCall == nil {
		fake.updateListReturnsOnCall = make(map[int]struct {
			result1 database.List
			result2 error
		})
	}
	fake.updateListReturnsOnCall[i] = struct {
		result1 database.List
		result2 error
	}{result1, result2}
}

func (fake *Querier) UpdateTaskSetCompletedAtNow(arg1 context.Context, arg2 database.DBTX, arg3 int64) (database.Task, error) {
	fake.updateTaskSetCompletedAtNowMutex.Lock()
	ret, specificReturn := fake.updateTaskSetCompletedAtNowReturnsOnCall[len(fake.updateTaskSetCompletedAtNowArgsForCall)]
	fake.updateTaskSetCompletedAtNowArgsForCall = append(fake.updateTaskSetCompletedAtNowArgsForCall, struct {
		arg1 context.Context
		arg2 database.DBTX
		arg3 int64
	}{arg1, arg2, arg3})
	stub := fake.UpdateTaskSetCompletedAtNowStub
	fakeReturns := fake.updateTaskSetCompletedAtNowReturns
	fake.recordInvocation("UpdateTaskSetCompletedAtNow", []interface{}{arg1, arg2, arg3})
	fake.updateTaskSetCompletedAtNowMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *Querier) UpdateTaskSetCompletedAtNowCallCount() int {
	fake.updateTaskSetCompletedAtNowMutex.RLock()
	defer fake.updateTaskSetCompletedAtNowMutex.RUnlock()
	return len(fake.updateTaskSetCompletedAtNowArgsForCall)
}

func (fake *Querier) UpdateTaskSetCompletedAtNowCalls(stub func(context.Context, database.DBTX, int64) (database.Task, error)) {
	fake.updateTaskSetCompletedAtNowMutex.Lock()
	defer fake.updateTaskSetCompletedAtNowMutex.Unlock()
	fake.UpdateTaskSetCompletedAtNowStub = stub
}

func (fake *Querier) UpdateTaskSetCompletedAtNowArgsForCall(i int) (context.Context, database.DBTX, int64) {
	fake.updateTaskSetCompletedAtNowMutex.RLock()
	defer fake.updateTaskSetCompletedAtNowMutex.RUnlock()
	argsForCall := fake.updateTaskSetCompletedAtNowArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *Querier) UpdateTaskSetCompletedAtNowReturns(result1 database.Task, result2 error) {
	fake.updateTaskSetCompletedAtNowMutex.Lock()
	defer fake.updateTaskSetCompletedAtNowMutex.Unlock()
	fake.UpdateTaskSetCompletedAtNowStub = nil
	fake.updateTaskSetCompletedAtNowReturns = struct {
		result1 database.Task
		result2 error
	}{result1, result2}
}

func (fake *Querier) UpdateTaskSetCompletedAtNowReturnsOnCall(i int, result1 database.Task, result2 error) {
	fake.updateTaskSetCompletedAtNowMutex.Lock()
	defer fake.updateTaskSetCompletedAtNowMutex.Unlock()
	fake.UpdateTaskSetCompletedAtNowStub = nil
	if fake.updateTaskSetCompletedAtNowReturnsOnCall == nil {
		fake.updateTaskSetCompletedAtNowReturnsOnCall = make(map[int]struct {
			result1 database.Task
			result2 error
		})
	}
	fake.updateTaskSetCompletedAtNowReturnsOnCall[i] = struct {
		result1 database.Task
		result2 error
	}{result1, result2}
}

func (fake *Querier) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.deleteListMutex.RLock()
	defer fake.deleteListMutex.RUnlock()
	fake.deleteTaskMutex.RLock()
	defer fake.deleteTaskMutex.RUnlock()
	fake.insertListMutex.RLock()
	defer fake.insertListMutex.RUnlock()
	fake.insertTaskMutex.RLock()
	defer fake.insertTaskMutex.RUnlock()
	fake.selectListMutex.RLock()
	defer fake.selectListMutex.RUnlock()
	fake.selectListsMutex.RLock()
	defer fake.selectListsMutex.RUnlock()
	fake.selectTasksForListMutex.RLock()
	defer fake.selectTasksForListMutex.RUnlock()
	fake.updateListMutex.RLock()
	defer fake.updateListMutex.RUnlock()
	fake.updateTaskSetCompletedAtNowMutex.RLock()
	defer fake.updateTaskSetCompletedAtNowMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *Querier) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ database.Querier = new(Querier)
